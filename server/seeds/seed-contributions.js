require('dotenv').config()

module.exports = { 
    seedContributions: [
        {
            "status": 100,
            "contribution_keyword": "코딩",
            "contribution_title": "Full IM 29기 15주 회고록",
            "contribution_url": process.env.DEVZINE_CLIENT_ENDPOINT + '/article/con-1',
            "contribution_content": "\n                저의 전공은 산업디자인이고, 전직은 웹디자이너(운영디자인)예요. ‘디자인+코딩’에 관심이 있어 웹퍼블리셔 국비지원 학원을 다녔고 성적우수상을 받으며 행복하게 수료했어요. 하지만 취업시장에서 새로운 직군으로 이직하기엔 저의 코딩 실력이 부족했어요.\n                고민 끝에 코드스테이츠에 지원했고, 통과했고, 섹션 1,2,3을 거쳐 공부했고, HA 1,2 테스트를 봤고, 어제 마지막 HA 3 테스트를 봤고, 오늘 오전 9시에 통과 메일을 받았어요. (3개월 동안 일어난 일)\n                글을 본격적으로 적기 전, 짧게 자기소개부터 한 이유는 제가 ‘#멘탈관리가_중요했던_섹션3’라고 태그를 붙였던 것과 연관되어 있어요. 태그와 관련된 글은 비전공자고 멘탈관리에 어려움을 느꼈던 분이라면 공감되는 글이 많을 거예요.\n                #멘탈관리가_중요했던_섹션3\n                ( 이 부분은 case by case여서 공감 안 될 수 있어요. )\n                프로그래밍 언어로 취급받지 못 하는 HTML, CSS를 배운 저는 스스로 순수한 비전공자로 생각했고 다른 프로그래밍 언어를 배워 지식이 있는 분들과의 차이를 매일 실감하고 ‘아무리 노력해도 안 된다.’라는 생각을 많이 했어요.\n                섹션1, 2 때도 이런 생각은 있었지만 그래도 저와 공감되는 분들이 많았는데 섹션3 때는 현저히 적었고 ‘정말 코딩 잘하는 사람들만 남아있고, 공감을 나눌 수 있는 사람이 없다.’라고 느꼈어요. 집중도 안 되고, 외롭고 멘탈 관리가 안 되었어요.\n                지금은 생각을 바꾸려고 노력하고 있고, 멘탈도 이전보다 강해졌어요.\n                // ! 첫번째, 잘하는 전공자 & 비전공자와 나의 차이를 신경쓰지 말자.\n                솔직히 차이를 안 느낄 수가 있나요? 페어로 둘이 만나고 제가 지식이 없어 매번 짐이 되는 것 같은데 그 차이를 느낄 수 밖에 없죠. 그런데 그 차이에만 신경쓰지 말고, 결과적으로 배워서 얼마나 익힐 수 있는지를 신경쓰는게 좋아요.\n                글은 저렇게 쉽게 써놓아도, 쉽지 않은 일이에요. 그래도 노력해보세요. 분명 더 좋아질 거예요.\n                너무 차이를 신경쓰다가 다른 분께 무례하게 대할 수도 있어요. ‘너는 당연히 잘하니깐 이런 것도 당연히 잘하겠지’ 라고 부담감을 주거나 ‘내 앞에서 어렵다는 말 하지 말아줄래?’같이 그 분의 노력을 대수롭지 않게 생각할 수 있어요.\n                이건 자신만 생각하는 것이기 때문에 주의하는 게 좋아요.\n                // ! 두번째, 모든 사람에겐 장점이 있고, 물론 나에게도 장점이 있다.\n                코딩학원이고 앞으로 취업을 위해 코딩 잘하는게 제일 큰 장점이죠. 하지만 그것 말고도 다른 장점도 많아요. 영어를 잘하거나 해피 바이러스가 뿜뿜하거나 침착하거나 문제 파악이 빨라 해결방법도 빠르게 찾을 수 있거나 등등\n                제가 디자이너였고, CSS를 배웠다는 점도 장점이 될 수 있죠. 모두에겐 장점이 있으니깐! '나에겐 아무것도 없어' 하고 우울해하지 말아요.\n                코드스테이츠 다니기 전과 지금의 코딩 실력이 다른 것처럼 얼마나 시간을 쏟고, 지속적으로 공부하느냐에 따라 코딩 실력을 늘어날 거예요. 지금은 어려움을 겪더라도 꾸준히 해보세요.\n                ‘실력이 잘 안 느는 것 같아..’라고 느낄 땐 섹션1 때 풀었던 코플릿 과제처럼 이전에 풀었을 때 어려웠던 문제를 풀어보세요. 그럼 확실하게 실력이 는 것을 알 수 있어요. (여기서 토이문제는 뺍시다. ㅋㅋㅋ)\n                저희의 목적이 취업이기 때문에 다른 사람들과 비교되고 부족한 코딩 실력만 보일 수 있어요. 예전의 나보다 잘해야하는건 당연하고, 현재의 내가 부족해보여서 슬플 수 있어요.\n                솔직히 이부분은 당장의 완벽한 해결방법은 없다고 봐요. 부정적인 생각은 갈수록 깊어져요. 그러니깐 생각을 바꿔야 해요, ‘앞으로의 나도 잘할거다’라고. 지금의 부족한 내가 계속 부족하진 않을테니깐, 꾸준히 공부하면 나에게 맞은 회사를 찾고, 좋은 동료들과 만나 시너지를 얻을 수 있을테니깐.\n                지금의 노력이 헛되지 않게 나쁜 감정에만 얽매이지 말고 같이 화이팅해요! (적당히 부정적인거는 자극이 되어 도움될 수 있지만 너무 부정적이거나 나쁘면 안 좋아요.)\n                #마지막_HA\n                한달에 한 번 오는 HA 테스트가 드디어 어제로 끝이 났어요. HA 테스트 한 줄 평을 하자면 ‘학습했던 것보단 어렵지 않은, 반전있는 HA 테스트’\n                섹션3의 학습은 백엔드 위주라 개념 이해하는 것조차 어려웠어요. 섹션1 때는 어렵다고 느껴도 운동하면서 건강은 챙겼고, 운동 못 한 섹션2 때는 어렵다고 말했어도 당일 복습으로 개념은 이해했어요. 섹션3 때는 운동도 못 하고 개념도 제대로 모르고 ㅋㅋㅋ 토이 문제는 여전히 어렵고!\n                어렵다 어렵다 했지만 이번에도 저 통과했어요! 오후 2시부터 오후 6시까지 코플릿 2문제 풀고, 다음 날 통으로 과제형 문제를 푸는 것이 HA 테스트였어요. 코플릿 문제는 1시간 안 넘겼고, 과제형 문제는 4시간 안 넘겼어요. (과제형은 통과보단 실제 작동되게 하려고 하니깐 더 오래 걸렸어요.)\n                섹션1, 2 회고록처럼 간단히 제가 공부한 방법을 알려드릴까 해요.\n                // * 첫번째, 놓칠 수 없는 알고리즘 스터디\n                섹션2때도 스터디를 했지만 목적은 없이 모각코 느낌으로 매일 했었어요. 이번에는 '알고리즘'으로 스터디의 목적이 있고 일주일에 2번 만나서 문제를 풀었어요.\n                만날 때마다 어떤 알고리즘 유형을 풀지 정했고, 공통문제로 풀 1문제 선택했고 각자 개인문제 1개씩 더 풀어오기로 했어요. 스터디는 노션을 통해 내용을 정리했고, 디스코드로 서로 얘기 나눴으며, github에 푼 문제들은 push했고, 구글밋으로 만났어요.\n                섹션3 시작하는 첫 주부터 많이 분들이 스터디를 만들었어요. 알고리즘 스터디가 대부분 많고 추가로 프로젝트형 스터디를 하는 분들도 있어요. 선택이 아닌 필수 느낌이라 만들어야 한다는 부담감이 있었고 어떤 분과 해야할지 몰랐던 저에게 다행히 이전 페어분께서 같이 만들어보자고 하셔서 알고리즘 스터디를 만들었어요.\n                하고 싶은 분들이 꽤 많아요. 용기내서 같이 해보자고 해보세요! 혼자가 편하다면 혼자 하되, 알고리즘 문제를 꾸준하게 일주일에 한 번은 풀어보는 걸 추천해요.\n                ( 저는 매일 프로그래머스 1문제씩 풀기를 했었는데요, 당일 복습도 어렵고 문제 난이도도 계속 높아져서 현재는 중단했어요. 섹션3 동안 25문제 풀었어요. )\n                // * 두번째, 스프린트 복습을 넘어 HA테스트 구현하기\n                HA테스트 전에 밑바닥부터 구현을 해보았어요. 완벽하게 어떤 문제로 나올지는 모르지만 client, server 파일을 만들고 인증서 만들고, 연결하고, 마이그레이션하고.. 그동안 배웠던 내용을 하나하나 적용해보았고, 잘 모르는 부분은 검색해서 배우고 채워넣었어요.\n                프로젝트를 할 땐 더 어렵고, 테스트 보기 전에 구현하면 통과 확률이 더 높다고 생각해서 구현했는데 여러가지 고난을 겪어서 참.. 재밌었어요... '이정도도 제대로 못 하는데 과연 내가 프로젝트를 할 수 있을까?'걱정했지만 오랜 시간을 쏟아부어 구현되었을 때 너무 기뻤어요. 그리고 HA테스트를 빨리 파악해서 풀 수 있었어요.            \n                스프린트를 참고해서 구현했으며 스프린트에는 테스트 때문에 여러가지가 추가되었지만 저는 테스트가 필요없기 때문에 필요한 것만 골라 설치하고 코드를 짰어요.\n                테스트가 없기 때문에 제대로 구현되었는지 확인이 어려웠지만, Postman과 MySQL Workbench를 잘 활용해서 확인했어요. 구현하는 거.. 참 재밌습니다.. 어차피 프로젝트 때 할 거! 다들 HA테스트 전에 해보세요! 제가 겪었던 어려움!! 다들 느끼세요!!\n                #프로젝트_시작\n                이제 곧 프로젝트를 시작해요. 언제나 다음 단계는 겪어 본 적이 없어서 무서워요.\n                ‘내가 팀원들에게 짐이 되지 않을까?’, ‘나랑 같은 팀하고 싶은 사람이… 있을까?’, ‘정말 한 번도 해본 적 없는데 어떤 프로젝트를 하면 되지?’, ‘프로젝트한 것들 보면 추가로 새로운 스킬이 많은데.. 배워야할게 너무 많은데?!’ 처럼 고민이 너무너무 많아요!\n                섹션3를 시작할 때부터 HA테스트보단 프로젝트를 고민하는 분들이 많았고, 스터디도 프로젝트팀을 구성하기 위한 전초전같은 느낌이 있었죠.. 미리 마음 맞는 분들과 팀을 짜도 좋지만! 코드스테이츠를 통해 같이 할 팀이 정해지고, 새로운 분들과 만나 기획하고 협업하는 것도 좋을 거예요.\n                만약 보시는 29기분들이 있다면… 29기분들 같이 열심히 해보아요! 페어로 만나지 못 하고 프로젝트로 넘어가 뵙지 못한 분들도 있어 아쉽지만 모두들 멋진 프로젝트로 만나요! 화이팅 화이팅!\n                ",
            "contribution_date": new Date("2021-07-15T00:00:00Z"),
            "user_email": "jonga6431@gmail.com",
            "contribution_id": 1,
        },
        {
            "status": 100,
            "contribution_keyword": "코딩",
            "contribution_title": "[Database] Redis Vs Memcached",
            "contribution_url": process.env.DEVZINE_CLIENT_ENDPOINT + '/article/con-2',
            "contribution_content": "\n                Caching Solution\n                캐싱은 어플리케이션 성능 향상에 가장 많이 기여하는 단계이다. 캐시 서버 또는 in-memory cache 를 구현하기 위해 많이들 알아보는 것이 Redis 와 Memcache 인데, 이 두 가지를 비교해 보며 구현하고자 하는 서비스에 더 적합한 캐시 솔루션인지 알아보자. \n                Memcached 는 2003 년에 나온 고성능 캐싱 솔루션이다. Redis 는 비교적 최근에 나왔으며 (2009년), 여러 기능을 탑재한 캐싱 솔루션이다. AWS 에서는 이들의 공통점과 차이점을 다음과 같이 정리하고 있다.\n                표로 보니 뭔가 Memcached 가 Redis 에 비해 할 줄 아는 것이 적어보이는데, 실제로도 그렇다. Memcached 는 단순한 작업을 위해 고안된 반면 Redis 는 여러 케이스까지 고려할 수 있도록 추가적인 기능이 탑재되었다. 하지만 이 둘의 기본적인 기능은 같다는 점을 유의하여야 한다. \n                Memcached & Redis : 공통점\n                Memcached 와 Redis 는 모두 in-memory storage (database) 로, SSD 와 같은 Disk 보다 데이터 반환 속도가 빠르다는 장점이 있다. 다시 말하면 서버의 성능을 향상하는 것이 목적인 캐시에 최적화 되어 있다는 의미이다.  기본적으로는 NoSQL 데이터베이스로, key-value 쌍을 활용해 데이터를 저장한다. \n                Memcached & Redis : 차이점\n                그렇다면 캐시 선택에 앞서 고려해야 할 중요한 차이점은 무엇이 있을까.\n                1. 데이터 타입\n                Memcached 는 데이터를 문자열로만 저장하는 반면, Redis 는 조금 더 다양한 자료형을 지원한다. 따라서 Memcached 를 사용할 때는 JSON.stringify 등의 메서드를 통해 데이터를 전부 변환하여 저장하고, 가져올 때도 파싱을 해야 하는 반면 Redis 를 사용할 때는 바로 원하는 데이터를 다룰 수 있다. \n                2. 데이터 지속성\n                Memcached 에는 없지만 Redis 에는 특징 중 하나는 데이터 지속성 (Persistence) 이다. in-memory storage 는 원래 단기간 저장소이기 때문에 컴퓨터가 꺼지거나 프로세스가 종료되면 임시 저장되었던 데이터가 전부 삭제된다. Memcached 는 이러한 특성 때문에 데이터를 날리게 될 위험성이 높다. \n                반면 Redis 에는 AOF Log 와 RDB Snapshot 이라는 기능이 있다. 이는 각각 Append Only File 과 Redis Database Backup File 의 약어로, in-memory 에 저장된 데이터를 Disk에 백업해주는 기능이다. 이러한 기능들을 통해 Redis 는 서버에 장애가 발생해도 데이터 유실 없이 보관되었던 데이터를 복구할 수 있으며, 서버 안정성에도 크게 기여한다.\n                3. 데이터 길이 \n                Redis 의 key 또는 string 은 512MB 에 달하는 크기를 가질 수 있는 반면 Memcached 의 key 는 250 바이트의 크기밖에 갖지 못한다. 따라서 저장할 데이터 값이 크다면 Redis 를 이용하는데 이점이 있다.\n                4. 데이터 삭제 방법\n                Memcached 나 Redis 나 모두 LRU (Least Recently Used) 방법을 통해 잔여 기간이 긴 데이터를 삭제한다. 그러나 Redis 는 No Eviction (데이터를 삭제하지 않고 메모리가 차면 key 추가를 허용하지 않음) 이나 TTL (Time to Live : TTL 표기가 된 데이터를 먼저 지우고 나머지는 아직 유효한 것으로 간주함) 등의 추가적인 방법을 통해서도 데이터를 관리할 수 있다. \n                5. 레플리카\n                Redis 는 자체적으로 Replica 를 형성하여 두 개의 다른 서버에서도 동일한 데이터가 보관될 수 있도록 하지만, Memcached 는 외부 소프트웨어를 사용하지 않는 이상 Replica 를 제공하지 않는다. \n                6. 클러스터\n                클러스터링이란 여러 개의 인스턴스를 생성해 하나로 연결하는 작업을 의미하는데, 이를 통해 서비스의 접근 가능성을 높일 수 있다. 가령, 여러 개의 Redis node 가 하나의 클러스터로 연결된 경우, 서버 1 에서 Redis node 2 에 있는 정보에 대한 요청이 들어온다면 Redis node 1 는 바로 node 2 에 접근해 정보를 반환할 수 있다. \n                Redis 는 클러스터링을 지원하기 때문에, 이를 잘 활용한다면 서비스의 성능이 개선되는 것뿐만 아니라 확장 가능성도 높여주게 된다. \n                + 7. Multithread \n                무언가가 Multithread 란 것은 하나의 프로세스에서 여러 개의 작업을 동시에 수행할 수 있음을 의미하는데, 원래 Memcached 와 Redis 중 Memcached 만 Multithread 를 지원해 더 좋은 성능을 제공했었다. \n                그러나 Redis 버전이 업데이트 되며 버전 6부터는 Redis 에서도 Multithreading 이 지원되기 시작했다. \n                Memcached vs Redis : 무엇을 사용해야 하는가\n                정답은 없다. 서두에 언급했듯 서비스를 가장 잘 알고 있는 것은 그 서비스를 개발한 사람이기 때문에, 복잡한 캐싱 기능이 필요 없다면 단순한 Memcached 를 사용하면 될 것이고, Redis 의 이점이 필요하다면 Redis 를 쓰면 될 것이다.\n                그러나 알아볼수록 대부분의 사람이 Memcached 을 쓰느니 여러 설정을 할 수 있는 Redis 를 선택하는 경향을 보인다. 이번 프로젝트에서는 나도 Redis 를 활용해 캐싱을 하게 되었는데, Redis 의 이점을 최대한 누려보길 기대해본다. \n                ",
            "contribution_date": new Date("2021-08-10T00:00:00Z"),
            "user_email": "haeun.yah@gmail.com",
            "contribution_id": 2,
        },
        {
            "status": 100,
            "contribution_keyword": "코딩",
            "contribution_title": "[Network] 프록시(Proxy) 란?",
            "contribution_url": process.env.DEVZINE_CLIENT_ENDPOINT + '/article/con-3',
            "contribution_content": "\n                Proxy 서버란?\n                클라이언트의 요청을 대리해서 처리해주는 서버로, 보통 보안상의 문제로 인해 직접 서버와 통신하지 못할 때 중계하는 역할을 맡는다. 실제 접근 호스트가 아닌 다른 호스트에서 접속한 것처럼 위장할 수 있어, 익명성을 보장한다.\n                또한, 캐싱 기능이 있어 접속 속도를 향상시킬 수 있으며, 불필요한 외부와의 연결을 줄여 트래픽을 감소할 수 있다.\n                서버의 위치에 따라 크게 Forward Proxy 와 Reverse Proxy 로 나뉘지만, 하나의 프록시에서 두 기능을 모두 수행할 수 있다.\n                Forward Proxy\n                클라이언트와 인터넷 사이에 위치한다.\n                클라이언트 대신 서버에 요청을 보내준다.\n                Reverse Proxy\n                인터넷과 서버 사이에 위치한다.\n                서버의 응답을 클라이언트에 대신 전달해준다.\n                Load Balancing 이란?\n                \"분산처리\" 를 의미하며 요청량이 많을 때 이를 적절히 분배하여 여러 대의 서버에 나눠서 분산처리할 수 있도록 조정하는 작업이다.\n                프록시 서버를 부하 분산 장치 (Load Balancer) 로 사용할 수 있다.\n                클라이언트 요청이 많은 경우 서버 한 대를 scale-up 하여 처리할 수 있는 데이터의 양을 늘리는 방법도 있지만, 한 번에 처리할 수 있는 요청의 수는 동일하다. (그리고 데이터가 많아지면 과부하가 올 수도 있다) 하지만 scale-up 대신 load balancing 을 선택할 경우 한 번에 처리할 수 있는 요청의 수가 늘어난다.\n                ",
            "contribution_date": new Date("2021-06-05T00:00:00Z"),
            "user_email": "haeun.yah@gmail.com",
            "contribution_id": 3,
        },
        {
            "status": 100,
            "contribution_keyword": "코딩",
            "contribution_title": "[Database] Express/NodeJS 에서 Redis 사용하기",
            "contribution_url": process.env.DEVZINE_CLIENT_ENDPOINT + '/article/con-4',
            "contribution_content": "\n                Redis 란? \nRemote Dictionary Server (DB) 이며, In-memory Data structure Store 로, 메모리 상에 데이터를 저장한다. 다양한 자료 구조를 저장하지만, 기본적으로 모든 데이터는 Key-Value 쌍을 이루기 때문에 NoSQL DB 로 활용된다. 디스크에 데이터를 저장해 속도가 느린 RDBMS 등의 DBMS 보다 활용도가 높은 케이스가 종종 있는데, 그 대표적인 예가 캐시 (Cache) 이다.\n\n클라이언트에서 서버에게 데이터를 달라는 요청을 보내면 서버는 데이터베이스에서 데이터를 얻어오게 되는데, 동일한 요청이 여러 번 올 경우 계속 데이터베이스에서 같은 데이터를 찾는다. 이는 상당히 비효율적이며, 데이터의 크기에 따라 응답 속도가 계속 지연될 수 있기 때문에 클라이언트에게 좋지 않은 사용 경험을 줄 수 있다.\n                이 때, 요청 결과를 미리 저장해두었다가 동일한 데이터를 얻고자 하는 요청이 들어오면 저장한 결과를 바로 줄 수 있도록 하는 것이 \"캐시\" 다. 캐시는 자주 바뀌지 않지만 자주 접근되며, 사용자에게 빠르게 전달되어야 한다는 특징을 가지고 있기 때문에 SSD 등의 Storage 가 아닌 Main memory 에 저장된다. Redis 역시 서버에 캐시를 저장할 수 있도록 하는 in memory 중 하나이다. \n                3-tier 아키텍쳐에서는 기본적으로 클라이언트와 서버, 데이터베이스간의 통신이 이루어진다. 클라이언트가 서버에게 요청을 보내면 서버가 데이터베이스에서 데이터를 얻어와 클라이언트에게 응답하는 구조를 띠는데, 이 때 Redis 를 활용하면 응답 속도를 현저히 낮출 수 있다.\n                Redis 는 잘 활용하면 애플리케이션의 속도와 성능을 크게 증가시키는 역할을 할 수 있다. 물론 그러기 위해 in-memory 와 disk 의 차이, RAM 데이터의 휘발성 이슈 등을 사전에 잘 알아두어야 할 것이다. \n                ",
            "contribution_date": new Date("2021-07-18T00:00:00Z"),
            "user_email": "haeun.yah@gmail.com",
            "contribution_id": 4,
        },
        {
            "status": 100,
            "contribution_keyword": "코딩",
            "contribution_title": "Full IM 29기 17주 회고록",
            "contribution_url": process.env.DEVZINE_CLIENT_ENDPOINT + '/article/con-5',
            "contribution_content": "\n                저는 포토샵, 일러스트로 사이트를 디자인할 수 있고, 웹퍼블리셔로 html, css를 사용하여 구현할 수 있었어요. \n                그런데 이번에는 CRUD(create, read, update, delete)기능과 REST API를 설계해야했어요.\n\n                쉽게 말하자면, 회원가입에 글을 써서 회원가입 버튼이 누르면 실제 회원가입이 되고, \n                그 정보로 로그인이 되고, 게시글을 작성하거나 댓글을 작성하고 물건을 살 수 있고 .. 등등 실제로 웹사이트에서 작동하는 것들이 이미지적으로 뿐만 아니라 구현이 되어야해요. \n                (백엔드와 소통되어 데이터를 저장하고, 저장된 데이터를 사용할 수 있어야 해요.)\n단순 리뉴얼도 아니고 기획을 하여 새로운 사이트를 만들어야 해요. \n                저는 이전 기수분들 것을 보면서 아이디어를 내봤지만 뭐가 좋고, 나쁜 것인지 잘 구분이 안되었어요. (지금 프로젝트를 하고 나니 조금 알겠어요.)\n                프로젝트가 정해지고 프로젝트를 제대로 알기위해선 와이어프레임이 먼저 제대로 나와야겠다고 생각했고, 와이어프레임을 만들었어요. \n                그리고 css할 때 헤매지 않고 전체적인 통일성을 주기 위해서 ui 디자인이 필수적이란 생각에 ui디자인 또한 뒤어어 했어요.ui 디자인을 하고, 더미데이터를 만드는데 시간이 오래 걸리는 것 같아 초반에 기능 구현을 못 했어요. 그래서 ‘ui 디자인을 하는게 맞는것일까?’라는 생각을 많이 했고 중반까지만 해도 프론트엔드 진행속도가 안 나서 너무 슬펐어요.\n                예상치 못 한 오류! 시간은 째각째각\n                데스크탑 백라이트가 갑자기 나가면서 코드를 칠 수 없을 정도로 화면이 어두워졌어요. 그래서 급하게 수리기사님께 연락하고 중고 모니터로 교체했어요. (내 8만 5천원…)\n                아주 사소하게 axios의 정보를 담는 방법을 헤매기도 하고, 데이터 주고받는 것을 어떻게 확인해야할지 몰라 고민하기도 하고, 회원일 때와 아닐 때에 보여지는 화면이 다른 것을 어떻게 구현할지, header에 위에 어떻게 고정시킬지 등 하나하나 고민하며 코드를 입력했어요.\n                갈수록 많아지는 상태들과 주석. redux를 쓰면 상태관리에 편하고 새로고침해서 안 없어지고, styled components를 쓰면 편하다는 것을 알고는 있으나 적용하기까지 익숙해지기엔 시간이 오래 걸려서 이번엔 사용을 안 했어요.\n                2주의 시간 길고도 짧았다.\n                매일 1시쯤에 자고 어쩔땐 4시에 자기도 하고 주말에도 안 쉬고 팀들과 소통하면서 작업을 했어도 모르는게 많아서 한 번에 잘 넘어가는게 거의 없었어요. 진짜 최대한 걱정, 피해를 안 끼치고 싶어서 열심히 했으나 조금 무리였는지 시간은 덧없이 흘려가고…ㅠㅠ 백엔드분들도 프론트엔드 작업을 서포트해주시면서 적극 도와주셨어요! 우리팀 너무 좋아ㅠㅠ\n                매일 공부하고 코드 작업할 게 많았고 그래서 정말 매일이 짧게 느껴졌어요. 한편으론 매일 늦게까지 코드만 치고 있으니 이 생활이 끝나지 않을 것같아서 길게도 느껴졌어요.\n                그래도 막판에 전체적으로 기능이 작동될 때! 그리고 코드를 안 치고 발표 준비를 하게 될 때! 너무 감회가 새로웠어요.\n                아직 우리에겐 4주 프로젝트가 남아있다.\n                2주 동안 너무 고생해서 끝난 뒤에 홀로 여행갈 수 있는 본가에 갔어요ㅎㅎ 오랜만에 긴 외출이라 너무 좋고, 부모님과 친구들을 만나서 좋았어요! 이렇게 프로젝트 걱정없이, 컴퓨터 킬 필요없이 편히 쉴 수 있다는게 너무 꿈같았죠\n                주말에 푹 쉬고 와서 이 글을 정리중이고 내일부터 4주 프로젝트가 다시 시작해요. 4주 프로젝트.. 2주에 겪어봤으니 미래가 어느정도 예상 가능하네요. 주말에 푹 쉬었는데 다시 걱정이 돼요. ‘주말에 쉬지말고 ‘2주 프로젝트 분석’ 포스팅을 올렸어야 했는데..’, ‘scss나 반응형 코드, 인터렉션이나 아이디어를 더 생각했어야하는데..’ 등의 하면 좋을 것들만 생각나요.\n                잘 쉬고 왔으니 일단 걱정은 넣어두고, 이번의 쉼으로 완전히 재충전하였으니 내일부터 다시 힘내서 잘할 수 있을 거예요! 4주 프로젝트 화이팅!\n                ",
            "contribution_date": new Date("2021-08-02T00:00:00Z"),
            "user_email": "jonga6431@gmail.com",
            "contribution_id": 5,
        },
        {
            "contribution_keyword": "코딩",
            "contribution_title": "[WEB] Event Loop",
            "contribution_url": process.env.DEVZINE_CLIENT_ENDPOINT + '/article/con-6',
            "contribution_content": "JavaScript = Single Thread Language\n\nMemory Heap : 메모리 할당이 일어나는 곳(변수나 함수와 같은 객체들이 할당 되는 곳)\nCall Stack : 실행될 코드의 한 줄 단위로 할당되는 자료 구조\nWeb APIs : 비동기 처리\nQueue : 비동기 처리가 끝난 후 실행 될 콜백 함수가 차례로 할당\nEvent Loop : Queue에 할당된 함수를 순서에 맞춰 Call Stack에 할당\nProcess\n함수를 호출하면 Call Stack에 전달되고 값을 반환하면서 스택에서 제거\n\nrespond 함수에 호출된 콜백 함수인 setTimeout 안의 익명 함수가 Web API에 전달되면서 Call Stack에서 제거\nWeb API에서 작업이 완료되면 Call Stack대신에 Queue에 전달\n\n바로 Call Stack에 추가되지 않고 Event Loop에서 Call Stack이 비어있는 것을 확인한 후 Queue에 있는 항목이 Call Stack에 전달\n\nCall Stack에 호출된 함수에서 값을 반환하고 Call Stack에서 제거\n     \nExample\nconst foo = () => console.log(\"First\");\nconst bar = () => setTimeout(() => console.log(\"Second\"), 500);\nconst baz = () => console.log(\"Third\");\n\nbar();\nfoo();\nbaz();\n\nMicrotasks & (Macro)tasks\nMicortask : process.nextTick | Promise callback | queueMicrotask\n(Macro)task : setTimeout | setInterval | setImmediate\nEvent Loop의 동작 방식\nCall Stack에 있는 모든 함수가 실행\nCall Stack이 비어있을 때, Microtask에서 하나씩 Call Stack에 호출된 후 실행\nCall Stack과 Microtask가 전부 비어있는 경우, (macro)task를 확인하여 Call Stack에 호출된 후 실행",
            "contribution_date": new Date("2021-08-18T13:58:30.961Z"),
            "status": 101,
            "user_email": "idhyo0o@gmail.com",
            "contribution_id": 6,
        },
        {
            "contribution_keyword": "코딩",
            "contribution_title": "2021년 6월 15일 코드스테이츠 DAY-72 Dynamic Programming",
            "contribution_url": process.env.DEVZINE_CLIENT_ENDPOINT + '/article/con-7',
            "contribution_content": "Dynamic Programming 동적 프로그래밍\n \n\n동적 프로그래밍에는 문제를 더 작은 문제로 쪼개는 과정을 포함하고 있음.\n\n \n\n(작은 문제를 해결해야 그 다음 문제를 해결할 수 있는 구조가 되려나)\n\n \n\n동적 프로그래밍은 작은 문제를 해결한 다음 이에 대한 결과를 메모리에 저장해\n\n \n\n필요 시 언제든 해결된 문제의 결과에 접근할 수 있게 한다.\n\n \n\n(배열이나 객체 등 저장할 수 있는 것을 반드시 포함하겠구나 예상되네)\n\n \n\n동적 프로그래밍의 규칙\n\n \n\n이미 계산된 값들을 저장하고 해당 값들을 사용해야한다.\n\n(단, 이 방법은 중복 부분 문제와 최적 부분 구조가 존재하는 문제에만 적용할 수 있음)\n\n동적 프로그래밍은 부분 문제의 해결책을 해시 테이블과 배열, 행렬에 저장하며,\n\n \n\n이러한 방식을 메모이제이션이라고 부른다.\n\n \n\n동적 프로그래밍은 문제 해결 시 중복 부분 문제가 많은 경우 유용하다.\n\n \n\n어떤 문제의 최적 해결책을 해당 문제의 부분 문제들의 최적 해결책들을 사용해 찾을 수 있을 때\n\n \n\n이를 최적 부분 구조라 한다.",
            "contribution_date": new Date("2021-08-18T13:58:30.961Z"),
            "status": 102,
            "user_email": "bmanerdaniel@gmail.com",
            "contribution_id": 7,
        },
        {
            "contribution_keyword": "코딩",
            "contribution_title": "2021년 7월 6일 코드스테이츠 DAY-93 session 스프린트 깊은 탐구",
            "contribution_url": process.env.DEVZINE_CLIENT_ENDPOINT + '/article/con-8',
            "contribution_content": "인증/보안 세션에서 session을 접하였기에 당연히 session이 인증/보안을 위해 생겨난 무엇이라고 생각을 했다. \n\n \n\n하지만 세션은 인증/보안의 역할을 하기 이전에 브라우저가 서버에 어떠한 요청을 했을때\n\n \n\n이 요청을 어떤 브라우저가 보낸 것인지 식별하기 위해 서버에서 생성되는 기본 객체였다. 위 그림의 3을 보면 PW를 해싱한 값과 DB를 비교해서 로그인에 성공한다면 세션을 생성하고\n\n \n\nresponse의 cookie에 sessionID를 보내줌이라고 적혀있는 부분을 확인할 수 있다. \n\n \n\n하지만 코드스테이츠에서의 session sprint에서 로그인 요청을 받고 응답을 보내줄때에는\n\n \n\n3의 과정이 없어도 test case를 통과함은 물론이거니와 sprint이후 제공된 reference에도 3의 과정이 보이지 않았다.\n\n(세션 객체에 userId를 저장하는 부분은 있었지만... 쿠키에 sessionID를 보내는 부분이 없다.)\n\n \n\n(브라우저에서 최초로 서버에 요청을 보내면 서버쪽에서 브라우저를 식별할 수 있도록 세션이라는 기본 객체를 만든다.\n\n \n\n그 기본 객체안에는 세션ID가 있고 이 세션ID를 쿠키에 담아서 브라우저로 보내주면 \n\n \n\n브라우저는 앞으로의 모든 요청에 세션ID를 서버에 보낸다. \n\n \n\n서버는 요청에 포함된 쿠키의 세션ID를 통해 어떤 브라우저인지 식별할 수 있게 된다.)\n\n \n\n세션이 브라우저마다 하나씩 만들어지는 그리고 서버에 저장되는 특성을 활용해서\n\n \n\n로그인 관련한 중요한 정보 및 클라이언트에 보관하면 민감한 정보들을\n\n \n\n세션에 저장하여 인증/보안의 역할을 할 수 있게 하는 것이다. \n\n \n\n출처 : https://youtu.be/VrWK1VPW5Qg\n\n \n\n위의 과정을 아래의 그림으로 표현해 보았다. 브라우저(클라이언트)에 sessionID를 보내준다고 적었으나,\n실제로 client에서는 connect.sid라는 고유값만을 받게 된다.\nconnect.sid는 서버에서 지정한 secret(salt)과 sessionID를 암호화하여 만들어진 것이다.\n또한 쿠키에 connect.sid를 보내주는 등의 내가 고민했던 부분은\nmiddleware에 의해 자동으로 처리되기 때문에 \n직접 쿠키에 접근하거나 할 필요가 없다라는게 깊은 탐구의 결론이다.",
            "contribution_date": new Date("2021-08-18T13:58:30.961Z"),
            "status": 101,
            "user_email": "bmanerdaniel@gmail.com",
            "contribution_id": 8,
        },
        {
            "contribution_keyword": "코딩",
            "contribution_title": "[React 기초 문법] #3 state와 props",
            "contribution_url": process.env.DEVZINE_CLIENT_ENDPOINT + '/article/con-9',
            "contribution_content": "props와 state의 의미\n \n\nstate는 컴포넌트 내부에서 바뀔 수 있는 값을 의미한다. \n\nprops는 컴포넌트가 사용되는 과정에서 부모 컴포넌트가 설정하는 값으로 컴포넌트 내에서 읽을 수만 있다.\n\n따라서 props를 바꾸려면 부모 컴포넌트에서 바꾸어야만 한다 .\n\n \n\n공식문서에 의하면\n\n함수 컴포넌트나 클래스 컴포넌트 모두 컴포넌트의 자체 props를 수정해서는 안된다. \n모든 React 컴포넌트는 자신의 props를 다룰 때 반드시 순수함수\n(입력값을 바꾸려 하지 않고 항상 동일한 입력값에 대해 동일한 결과를 반환하는 함수)처럼 동작해야한다.\n라는 말이 있다. \n\n \n\n사용자의 액션, 네트워크의 응답 및 다른 요소에 대한 응답으로 시간에 따라 props가 컴포넌트 내에서 바뀌어야만 하는 상황이 있는데 이때 사용하는 것이 바로... state이다.\n\n \n\nstate의 종류 : 클래스형 컴포넌트의 state\n우선 클래스형 컴포넌트에서 state는 다음과 같이 constructor 메서드를 사용하여 작성할 수 있다. \n\nconstructor(props){\n\tsuper(props);\n    this.state = {\n\t\tname:'Daniel'\n\t};\n}\n위 예시에서 super()를 호출해주는 이유는 constructor 안에서 this를 사용하기 위해서\n\n \n\n그리고 클래스형 컴포넌트가 상속받고 있는 리액트의 Component 클래스가 지닌 생성자 함수를 호출하기 위함이다.\n\n \n\n constructor를 사용하지 않고도 클래스형 컴포넌트에서 state를 작성할 수 있는데 예시는 아래와 같다. \n\n \n\nstate = {\n\tname:'Daniel'\n}\n두 예시를 통해 알 수 있는 것은 state는 객체 형식이라는 것이다.\n\n \n\nrender 함수 안에서 state를 불러올 때는 this.state로(구조분해할당하여) 불러올 수 있고,\n\n \n\nthis.setState라는 함수로 state 값을 바꿀 수 있다. \n\n \n\nthis.state가 끝난 후 다른 작업을 실행하기 위해서는\nsetState의 두번째 파라미터로 다른 작업에 해당하는 콜백함수를 넣어주면 된다. \n \n\nstate의 종류 : 함수형 컴포넌트의 state(useState Hooks)\n \n\nuseState는 배열 구조분해할당을 통해 사용할 수 있으며 상태 초기값을 useState 함수의 인자에 넣어주면 된다. \n\n \n\n초기값은 반드시 객체가 아니어도된다. \n\n \n\nuseState 함수 호출 시 배열이 반환되는데 첫번째 인자는 상태이고,\n\n \n\n두번재 인자는 상태를 바꾸어 주는 set함수(혹은 setter 함수)이다.\n\n \n\nconst [name, setName] = useState(\"Daniel\")\n \n\nstate를 바꿀때에는 반드시 setState혹은 set함수를 사용해야하는데....\n\n \n\n즉 직접 state를 재할당하는 식으로 변경하면 안되는 것이다.(하지만 실제로 변경은 된다. 골때린다.)\n\n \n\n변경하면 실제로 바뀌지만 이것이 바로바로 화면에 rerendering 되지 않기 떄문에.....\n\n \n\n되도록이면 이렇게 사용하는 것을 지양하라고 한다.\n\n \n\n스프린트를 해오며 느낀 것은 배열이나 객체의 사본에 값을 넣어주어 업데이트 한 후\n\n \n\n그 사본을 set함수와 setState로 업데이트 해야한다는 것.",
            "contribution_date": new Date("2021-08-18T13:58:30.961Z"),
            "status": 102,
            "user_email": "bmanerdaniel@gmail.com",
            "contribution_id": 9,
        },
        {
            "contribution_keyword": "코딩",
            "contribution_title": "2021년 5월 16일 코드스테이츠 DAY-42 동기, 비동기 예습",
            "contribution_url": process.env.DEVZINE_CLIENT_ENDPOINT + '/article/con-10',
            "contribution_content": "1. 동기와 비동기의 차이점\n\n \n\n자바스크립트는 동기적이다. \n\n=> 호이스팅(var변수와 함수선언이 자동적으로 제일 위로 올라가는 현상)이 된 이후부터 코드가 작성순서에 맞추어 차례대로 실행된다는 말.\n\n \n\n비동기라는 말 : 언제 코드가 실행될 지 예측할 수 없다는 말. (ex: setTimeout을 이용한 경우 비동기적인 실행방법)\n\n \n\nsetTimeout(function(){\n        console.log('Hello World');\n}, 1000)\n콜백함수 : ('Hello World')를 console.log하는 setTimeout안의 함수는 바로 실행되는 것이 아니라, setTimeout이라는 함수의 parameter(인자)로서 지정한 시간 이후에 실행된다. 함수를 당장 실행하지 않고 1초가 지난 다음에 내 함수를 실행해줘, 내 함수를 나중에 다시(back) 불러줘(call)라는 것 처럼 parameter에 전달하는 함수를 callback함수라고 함.\n\n \n\n2. promise \n\n \n\npromise는 비동기적인 실행을 위한 자바스크립트 object이다.\n\n \n\npromise의 두가지 포인트 : 상태(state)(정보를 받아오는 중인지, 성공했는지 실패했는지), Producer(정보 제공자) vs Consumer(정보 소비자)(정보 제공자와 정보 소비자의 서로 다른 견해를 이해)\n\n \n\nState : promise가 만들어져서 지정한 operation을 수행 중일때는 pending상태이고 operation을 성공적으로 다 끝내면 fulfilled state가 되고 성공적으로 operation을 끝내지 못했을 때는 rejected state가 됨.\n\n \n\npromise를 만드는 순간 전달한 executer라는 callback 함수가 실행된다.",
            "contribution_date": new Date("2021-08-18T13:58:30.961Z"),
            "status": 101,
            "user_email": "bmanerdaniel@gmail.com",
            "contribution_id": 10,
        },
        {
            "contribution_keyword": "코딩",
            "contribution_title": "[Git] 브랜치 관리와 고급 기능",
            "contribution_url": process.env.DEVZINE_CLIENT_ENDPOINT + '/article/con-11',
            "contribution_content": "[Git] 브랜치 관리와 고급 기능\n브랜치는 공부했는데 이건 프로젝트 실전에서 사용하면서 확실하게 알 수 있을 것이다. 그래도 checkpoint로 나온 실습같은 문제는 정말 도움이 되었다! 이론 공부한 날마다 TIL에 크게 쓸 것이 없다..\n소스코드 나도 깔고 싶은데 우분투용은 없다 ㅜㅜ 스마트깃을 까는게 좋을까.. 고민중이다. 우선은 vscode git graph로 쓸 수 있다. 사용은 안 해봤지만 사용해보고 불편하면 스마트깃을 깔아야겠다. 이전 기수분들이 하신 프로젝트 보는데 완전.. 감성 자극하는 멋진 프로젝트도 있고 랜딩페이지가 너무 멋진 프로젝트도 있고..! 프로젝트 내용이 너무 좋은 것도 있고! 우와 진심 멋지다.\n// Achievement Goals\n1) Git 브랜치의 개념을 이해할 수 있다.\n:: 브랜치는 독립적으로 어떤 작업을 진행하기 위한 개념이다. master(main)에는 완성본만 merge하고, 완성되기 전까지는 dev브랜치와 feature브랜치를 이용해 코드를 push한다. 이렇게 브랜치 기능을 활용하면 코드를 통째로 복사한 후 원래 코드가 변경될 우려 없이 독립적으로 개발할 수 있다.\n2) Git으로 협업하며 브랜치를 나누는 이유를 이해할 수 있다.\n:: 브랜치 기능의 장점으로는 한 소스코드에서 동시에 다양한 작업을 할 수 있고, 소스코드의 한 시점과 동일한 상태를 만들고, 브랜치를 넘나들며 작업을 수행할 수 있다. 그리고 각각의 브랜치에서 생긴 변화가 다른 브랜치에 영향을 주지 않고 독립적으로 코딩을 진행할 수 있다.\n3) Git으로 프로젝트를 관리하며 브랜치를 생성, 전환, 병합할 수 있다.\n:: git branch로 새로운 브랜치를 만들고, git switch로 브랜치 전환하며, git merge로 브랜치를 병합한다. 이외에 여러가지 브랜치 명령어들이 있으니 주의하고 사용해야 한다.\nToday’s Key✨\nGit 브랜치를 이해하고 사용하는 방법을 배웠다.",
            "contribution_date": new Date("2021-08-18T13:58:30.961Z"),
            "status": 111,
            "user_email": "jonga6431@gmail.com",
            "contribution_id": 11,
            "hit": 9
        },
        {
            "contribution_keyword": "코딩",
            "contribution_title": "[2nd 프로젝트] 아이디어, 와이어프레임, 플로우차트(클라이언트)",
            "contribution_url": process.env.DEVZINE_CLIENT_ENDPOINT + '/article/con-12',
            "contribution_content": "[2nd 프로젝트] 아이디어, 와이어프레임, 플로우차트(클라이언트)\n파이널 프로젝트이자 2번째 프로젝트가 어제부터 시작했다. 어제부터이긴 했지만 어제는 팀 확정하고, 회고글 쓰고, 잠깐 만나서 아이디어를 각자 생각해서 내일 만나자는 얘기를 했다.\n1번째 프로젝트와 다른 점은 2주가 아니라 4주의 시간이 주어졌다는 점이다. 그리고 최종 발표영상이 코드스테이츠 유튜브에 올라간다. 올라간 영상들을 봤는데 다들 너무 잘해서 걱정되었다. 그렇지만 우리팀의 시너지가 좋기 때문에 이번 결과물도 좋을 것이다.\n팀은 변경될 수 있는데, 우리팀은 그대로 같이 하기로 했다. 우리팀은 4명으로 백엔드 2명, 프론트엔드 2명이다. 백엔드분들은 서버 외에 각각 배포와 DB를 담당하고 프론트엔드는 클라이언트 외에 각각 UI와 인터렉션을 담당하고 있다. 각자 맡은 일이 확실하고 서로 믿으니 작업하는데 잡음이 없었다.\n단지 어려웠던 점이라면 프로젝트를 처음 진행하여 속도가 어느정도로 나야하고 작업시간이 어느정도 걸리며, 어느정도 불륨을 해야할지 몰랐다. 2주 동안의 겪은 어려움을 이번 4주에서는 보완하여 작업을 진행할 것이다.\n\n팀확정된 지 다음날부터 아이디어를 본격적으로 얘기 나누기 시작했다. 원래는 2주 프로젝트를 보완하고 내용을 추가하여 4주 프로젝트로 할까 고민했다. 그만큼 2주 프로젝트가 애착이 크고, 보완해야할 점도 많이 보였고, 우리가 하고 싶었던 기능을 많이 뺐기 때문이다.\n나는 2주 프로젝트가 좋지만 코드를 보완하고 거슬리는 오류를 잡지 않으면 포트폴리오에 넣기 힘들다는 생각을 했다. 하지만 보완하는 것은 나 혼자서도 할 수 있지만 새로운 프로젝트를 만드는 것은 나 혼자서는 불가능하기 때문에 새로운 프로젝트를 진행하자고 의견을 냈고 그렇게 하기로 했다.\n화요일 각자 생각한 아이디어를 말했지만 정말 끌리는게 없었다. 그렇게 얘기를 계속계속 나누다가 아이디어가 오후 4시쯤인가? 결정되었다. 모두 다 생각하지 못 했던 것인데 대화 나누다가 서로 마음이 맞았다.\n그리고 나는 이후에 와이어프레임을 작업했고, 플로우차트는 내일 할까 하다고 와이어프레임을 잘 이해하기 위해선 플로우차트도 같이 보여주는 것이 좋을 것 같아 같이 작업했다.\n이제 내일 팀원들에게 공유하고 통과된다면 UI디자인을 들어가면 된다!",
            "contribution_date": new Date("2021-08-18T13:58:30.961Z"),
            "status": 100,
            "user_email": "jonga6431@gmail.com",
            "contribution_id": 12,
        },
        {
            "contribution_keyword": "코딩",
            "contribution_title": "[CS] 프로세스(Process)와 스레드(Thread)",
            "contribution_url": process.env.DEVZINE_CLIENT_ENDPOINT + '/article/con-13',
            "contribution_content": "프로세스란?\n프로그램이 컴퓨터에서 실행이 되고 있는 상태로 만들어주는 실행 프로그램이다.\n\n메모리에 올라와 실행되고 있는 프로그램의 인스턴스 (독립적인 객체)이다. (운영체제로부터 자원을 할당받은 작업의 단위이다)\n\n최소 한 개 이상의 스레드를 가진다.\n\n \n\n✨ 스레드란?\n프로세스 내에서 실제로 작업을 처리하는 주체이다.\n\n프로세스가 할당받은 자원을 이용하는 실행 흐름의 단위이다.\n\n스레드끼리 프로세스의 자원을 공유하면서 프로세스 실행 흐름의 일부가 된다.\n\n \n\n✨ 멀티스레드란?\n하나의 프로세스가 두 개 이상의 스레드를 가지는 경우이며, 여러 작업을 여러 스레드를 사용하여 동시에 처리하는 것을 의미한다.\n\n모든 스레드는 프로세스 내 메모리 영역의 내용을 공유한다.\n\n메모리 자원을 아낄 수 있으며, 응답 시간이 빠르다는 장점이 있지만, 동기화 문제 (계속 변동되는 자원에 접근하게 되는 오류)가 발생할 수 있다.",
            "contribution_date": new Date("2021-08-18T13:58:30.961Z"),
            "status": 100,
            "user_email": "haeun.yah@gmail.com",
            "contribution_id": 13,
        },
        {
            "contribution_keyword": "코딩",
            "contribution_title": "자료 구조 (기초)",
            "contribution_url": process.env.DEVZINE_CLIENT_ENDPOINT + '/article/con-14',
            "contribution_content": "자료 구조 이론과 풀이가 매치가 안된다. 활용이 안되는 것이다. 그래서 블로깅을 하고 넘어가야겠다. 블로깅하면서 나 또한 공부하는 것이기에 (기초)라고 제목에 넣었다. 풀이를 잘하게 된다면 다음엔 (심화)편으로 다시 블로깅하고 싶다.\n완전 기초적인 내용은 안 넣는다. ‘자료구조란 여러 데이터들의 묶음을 저장하고, 사용하는 방법을 정의한 것’ 과 같이 느낌 상으로 아는 것은 굳이 쓰지 않는다. 이번 (기초)편에서는 ‘개념은 알겠는데, 코드로는 어떻게 보여지는거야?’를 Stack, Queue, Graph (인접 행렬, 인접 리스트 / BFS, DFS) 순으로 익힌다.\nStack\n처음 들어간 데이터는 (1), 처음 나오는 데이터는 맨 끝의 (10)이다.\n들어간 곳과 나오는 곳이 같은 것이 Stack이다. Stack과 Queue는 빠르게 익힐 것이다. 구현도 간단하고 알고리즘 문제로 심각하게 나오지 않는다. 나오더라도 가볍게 나오고 이 개념을 알지 않더라도 풀 수 있기 때문이다. 물론 개념을 알면 ‘아~ 내가 이렇게 하는 것이 stack이구나!’를 알 수 있다.\n문제 ) 책이 쌓여있다. 위에 있는 책부터 3번 빼고, 새책들을 쌓고 다시 1번 뺐을 때, 제일 위에 있는 책은?\nconst 책들 = ['책1','책2','책3','책4','책5'];\n// '책1'이 제일 아래에 있고 '책5'가 제일 위에 있다.\nconst 새책들  = ['책6','책7'];\n브라우저의 이동 방법을 예시로 많이 들지만, 간단한 Stack 코드 활용법을 보는 것이기 때문에 책으로 예시 들었다. 책들에서 3번을 뺀다는 것은 위에서부터 빼니깐 [‘책3’, ‘책4’, ‘책5’]가 빠진다는 것이다. 새책이 들어가면 [‘책1’, ‘책2’, ‘책6’, ‘책7’]이 된다. 그리고 다시 1번 빼면 정답은 ‘책6’이다.\n코드로 간단히 적어보면 어떨까?\nconst 책들 = ['책1','책2','책3','책4','책5'];\nconst 새책들  = ['책6','책7'];\nfor ( let i = 0; i < 3; i++ ) { // 3번 빼기\n  책들.pop();\n}\n책들.push(...새책들); // 새책들 쌓기\n책들.pop(); // 1번 빼기\nconsole.log(책들); // ['책1', '책2', '책6']\nconsole.log(책들[책들.length-1]); // 정답 '책6'\n적어보았을 때, Stack 코드에는 push(), pop() 메소드를 사용한다는 것을 알 수 있다.\nQueue\n처음 들어간 데이터는 (1), 처음 나오는 데이터는 맨 앞의 (1)이다.\n들어간 곳과 나오는 곳이 다른 것이 Queue이다. 매번 새로운 것을 배울 때마다 나는 Queue같은 사람이라고 느낀다. 이전에 배운 내용은 사라지고, 새로 배운 것만 남기 때문이다. 안 쌓인다.. 그래서 쌓이게 할려고 하는 블로깅!\n문제 ) 인쇄를 한다. 인쇄목록에서 인쇄가 3번 되었고, 추가인쇄목록이 추가되었다. 그리고 1번 인쇄가 되었을 때, 다음으로 인쇄될 것은 무엇인가?\nconst 인쇄목록 = ['인쇄1','인쇄2','인쇄3','인쇄4','인쇄5'];\n// '인쇄1'이 맨 처음 순서이고 '인쇄5'가 제일 마지막 순서이다.\n// 인쇄목록에서 처음 들어간 순부터 차례대로 인쇄된다.\nconst 추가인쇄목록 = ['인쇄6','인쇄7'];\nstack은 책이었지만 queue는 인쇄를 예로 들어 간단한 문제를 만들었다. 인쇄에서 3번 인쇄가 되었다는 것은 [‘인쇄1’, ‘인쇄2’, ‘인쇄3’]이 작업이 안료되었다는 것이다. 추가가 되면 [‘인쇄4’, ‘인쇄5’, ‘인쇄6’, ‘인쇄7’]이 된다. 인쇄 1번이 더 완료되고 그 다음 인쇄될 것은 ‘인쇄5’이다.\n코드로 간단히 적어보면 어떨까?\nconst 인쇄목록 = ['인쇄1','인쇄2','인쇄3','인쇄4','인쇄5'];\nconst 추가인쇄목록 = ['인쇄6','인쇄7'];\nfor ( let i = 0; i < 3; i++ ) { // 3번 인쇄\n  인쇄목록.shift();\n}\n인쇄목록.push(...추가인쇄목록); // 인쇄목록에 추가\n인쇄목록.shift(); // 1번 인쇄\nconsole.log(인쇄목록); // [‘인쇄5’, ‘인쇄6’, ‘인쇄7’]\nconsole.log(인쇄목록[0]); // 정답 '인쇄5'\n적어보았을 때, Queue 코드에는 push(), shift() 메소드를 사용한다는 것을 알 수 있다.\nGraph\n그래프 표현 방식에는 ‘인접 행렬’과 ‘인접 리스트’가 있다.\n\nx, y축이 있거나, 위아래로 수량을 알 수 있는 일반적으로 검색해서 나오는 그래프가 아니라 위 그림의 서울, 부산, 청주의 지점을 연결하는 그래프를 뜻한다. 지하철 노선도, 네비게이션과 같은 모습이다.\n그리고 이 그래프를 코드를 만드는 방법으로 2가지 방법, ‘인접 행렬’과 ‘인접 리스트’이 있다. 문제를 많이 풀어보진 않았지만 인접 리스트보단 인접 행렬 유형이 조금 더 많았던 거 같다. (전체적으로 보면 지금까지는 이진 탐색 문제를 많이 풀었다.)\n‘인접 행렬’은 조금 더 집중해서 보면 좋지만 문제 유형 때문에 집중해서 보라는 거지 ‘인접 리스트’보다 좋아서 보라는 건 아니다. ‘인접 행렬’은 모든 데이터를 표시하기 때문에 메모리를 많이 차지한다.\n‘인접 행렬’을 그림과 함께 살펴보며 코드를 보면\nconst 도시들 = ['서울', '부산', '청주'];\nconst 인접행렬 =\n[[0,0,1],\n [1,0,1],\n [1,0,0]]\n// 서울에서 갈 수 있는 도시 경로\n[0][2] === 1 \n// 부산에서 갈 수 있는 도시 경로\n[1][1] === 1\n[1][2] === 1\n// 청주에서 갈 수 있는 도시 경로\n[2][0] === 1\n‘인접 행렬’에 관한 간단한 문제를 어떻게 만들 수 있을까?\n문제 ) 서울에서 친구와 만나 놀기로 했다. 지하철 노선도를 보며 놀러 갈 장소를 알아보고 있다. 홍대역, 강남역, 성수역으로 놀러가고자 한다. 홍대역에서 강남역으로 갈 수 있고, 강남역에서는 성수역을 갈 수 있다. 상수역은 홍대역과 성수역 둘 다 갈 수 있다. 이럴 경우 인접 행렬 형태로 나타내보자.\nconst 지하철 = ['홍대역', '강남역', '성수역']; // -> '정점' 의미\nconst 경로 = [\n['홍대역', '성수역'], \n['강남역', '홍대역'], \n['강남역', '성수역'], \n['성수역', '홍대역']]; // -> '간선' 의미\n예시 답변)\nconst 인접행렬 =\n[[0,0,1],\n [1,0,1],\n [1,0,0]];\n// 행은 출발 지하철역을, 열은 도착 지하철역을 나타낸다.\n// 행과 열의 지하철 순서는 지하철 순서와 같다.\n  // 첫번째 행, 첫번째 열은 '홍대역'\n  // 두번째 행, 두번째 열은 '강남역'\n  // 세번째 행, 세번째 열은 '성수역'\n// 1은 갈 수 있는 지하철, 0은 갈 수 없는 지하철을 의미한다.\n예시 답변처럼 만들기 위해 우선 0으로 채워진 3x3 배열을 만들어야 한다. 그리고 갈 수 있는 지하철은 1로 표시한다. 지하철이나 경로가 다양해 질 수 있으니깐 하드코딩 하지 말고 감안하여 만든다.\n// 그래프표현방식 1. 인접행렬\nconst 지하철 = ['홍대역', '강남역', '성수역'];\nconst 경로 = [\n['홍대역', '성수역'],\n['강남역', '홍대역'],\n['강남역', '성수역'],\n['성수역', '홍대역']];\nconst 인접행렬 = new Array(지하철.length).fill(0).map((row) => new Array(지하철.length).fill(0));\nfor (let i = 0; i < 지하철.length; i++) {\n  for (let j = 0; j < 경로.length; j++) {\n    let 경로_출발지 = 경로[j][0];\n    let 경로_도착지 = 경로[j][1];\n    let 지하철_출발 = 지하철[i];\n    if (경로_출발지 === 지하철_출발) {\n      if (경로_도착지) { \n        인접행렬[i][지하철.indexOf(경로_도착지)] = 1;\n        // 인접행렬[지하철.indexOf(경로_도착지)][i] = 1;  \n        // -> 무향(양방향)일때 포함\n      }\n    }\n  }\n}\nconsole.log(인접행렬); // 정답 [[0,0,1],[1,0,1],[1,0,0]]\n‘인접 행렬’을 만들 때 인접행렬 틀을 만든 것이 우선이다. for문을 활용하여 ‘1’을 채워 넣는다. 그럼 위 문제를 ‘인접 리스트’로는 어떻게 만들 수 있을까?\n// 그래프표현방식 2. 인접리스트\nconst 지하철 = ['홍대역', '강남역', '성수역'];\nconst 경로 = [\n['홍대역', '성수역'],\n['강남역', '홍대역'],\n['강남역', '성수역'],\n['성수역', '홍대역']];\nconst 인접리스트 = {};\nfor (let i = 0; i < 지하철.length; i++) {\n  인접리스트[지하철[i]] = [];\n}\nfor (let i = 0; i < 경로.length; i++) {\n  인접리스트[경로[i][0]].push(경로[i][1]);\n  // 인접리스트[경로[i][1]].push(경로[i][0]); \n  // -> 무향(양방향)일때 포함\n}\nconsole.log(인접리스트); \n// { '홍대역': [ '성수역' ], '강남역': [ '홍대역', '성수역' ], '성수역': [ '홍대역' ] }\n‘인접 리스트’를 만들 때 인접 리스트 틀을 만든 것이 우선이다. for문을 활용하여 정점를 채워 넣는다.\nGraph\n너비 탐색은 ‘BFS’과 깊이 탐색은 ‘DFS’가 있다.\n이론 공부할 때 그래프, 인접 행렬, 인접 리스트, BFS, DFS를 배웠고 그림을 보며 개념을 익혔지만 그들의 관계를 잘 몰랐다. 갈 수 있는 경로 찾고, 가까운 순으로 찾고.. 따로따로 푸는 거 아니야?\n결론을 말하자면 BFS는 ‘인접 행렬 or 인접 리스트’와 ‘Queue’와 ‘visited(방문했던 곳)’을 쓰고, DFS는 ‘인접 행렬 or 인접 리스트’와 ‘Stack’와 ‘visited(방문했던 곳)’을 써서 푼다. (간선으로 정보가 주어질 때는 ‘인접 행렬 or 인접 리스트’를 사용해야 하고, ‘인접 행렬 or 인접 리스트’로 정보가 주어질 때 그것을 활용하면 된다.)\n\n위 내용은 무향을 기준으로 하였다. (무향이 아닌 단방향일 경우는 따로 표시하겠고, BFS, DFS가 2차 배열로 만들어질것이다.) 대부분 문제에선 그래프까지 그려 보여줄지 모르겠다. 보여주면 좋지만 간선 혹은 인접행렬이나 인접리스트로 정보 줄 확률이 높다. 아래에 BFS에 queue를 활용하고, DFS에 stack를 활용한 것처럼 문제를 풀면 된다.\n문제는 많이 안 풀어봤지만 ‘가까운 순으로 모든 지역을 방문할 경우 어떤 순일까?’ 처럼 모든 경로를 지났을 때를 물을 수 있다. 혹은 단방향이 있을 경우, ‘모든 지역을 지나가 되는 경로는 몇 개일까?’ 혹은 ‘끝까지 다니며 모든 지역을 방문할 경우 경주는 몇 번째로 방문하게 될까?’ 같은 유형이 있을 수 있다. (문제를 많이 안 풀어본 내기준에서 생각한거라 부족하다. 문제를 많이 풀어보고 심화편에서 실제 알고리즘 문제로 나올만한 문제를 예시 들어야겠다.)",
            "contribution_date": new Date("2021-08-18T13:58:30.961Z"),
            "status": 111,
            "user_email": "jonga6431@gmail.com",
            "contribution_id": 14,
            "hit": 14
        },
        {
            "contribution_keyword": "코딩",
            "contribution_title": "[Insights] 배달의민족 CEO가 말하는 \"좋은 개발자",
            "contribution_url": process.env.DEVZINE_CLIENT_ENDPOINT + '/article/con-15',
            "contribution_content": "중요한 것은, 개발자라고 하면 스스로를 코딩하는 사람으로 정의하지 않았으면 좋겠다.\n결국은 우리에게 주어진 비즈니스 문제를 해결하는 사람으로 생각하면 좋겠다.\n \n\n \n\n카이스트 출신 배달의 민족 전 CTO 현 CEO 김범준의 인터뷰 영상을 보고 느낀 점 몇 가지를 정리해본다.\n\n \n\n1. 개발자는 문제를 해결하는 사람이다\n개발자의 본질 또는 핵심 역량을 묻는 글도 답하는 글도 많지만, 대부분 '타고난 머리' 또는 '재능, 실력' 등의 논의 이상을 못하고 만다. 김범준 대표는 그의 인터뷰에서 이러한 점을 지적하듯 \"개발자는 코딩하는 사람 이상의 가치를 지닌 사람\"이라고 명쾌히 짚어주며, '문제해결능력'을 괄목하여 얘기한다. \n\n \n\n코딩을 잘하는 개발자란 곧 문제를 잘 해결하는 개발자라고 생각한다. 그래서 개발과 문제해결 역량은 떼어놓을 수 없다. 특히 현재와 같이 일상의 가장 깊은 영역까지 소프트웨어가 침투해 있는 시대일수록 사람들의 편의를 증진하고 일상의 문제를 해결함으로써 가치를 창출하는 개발자가 좋은 개발자로 여겨지는 듯하다. 개발을 통해 만들 수 있는 것이 더욱 다양해졌으며, 가능성도 커졌다. 자연스레 '개발자'라는 직업의 의미 역시 함께 변화하고 있으며, 아마도 김범준 대표가 강조하고 싶었던 것은 이러한 변화의 파도에 올라타 성장하는 것의 중요성이었던 것 같다. \n\n \n\n문제를 잘 해결하는 사람이 되기 위해서는 문제의 핵심을 잘 파악하는 분석력과 해결에 나서는 실행력이 고루 가춰져 있어야 한다. 개발자에게 다소 많은 것을 요구하는 것 아니냐 싶을 수 있겠지만 사실 코딩을 하다보면 결국엔 필요한 역량이다. 버그가 발생했을 때 버그의 원인을 볼 줄 아는 능력과 코드를 끝까지 붙잡고 해결해내는 끈기가 곧 문제해결 능력이다. 좋은 개발자, 혹은 성장하는 개발자가 되기 위해서는 이러한 역량을 그저 본인의 코딩 세계에서만 활용할 것이 아니라, 비즈니스와 서비스의 가치를 개선하는 데도 활용해야 한다는 것이 핵심이다. \n\n \n\n2. 개개인의 실력보다 더욱 중요한 것은 팀웍이다\n물론 개인의 코딩 실력이 중요하지 않다는 것은 전혀 아니라고 생각한다. 적어도 좋은 팀웍이 나올 수 있을 수준의, 즉 팀원들에게 민폐가 되지 않을 정도의 기본적인 실력은 갖춰야 할 것이다. \n\n \n\n다만, 개인의 실력을 과신한 나머지 팀과의 협업을 소홀히 하는 것은 좋은 개발 문화를 만들지 못한다는 점을 염두에 두어야 한다. 김범준 대표의 인터뷰를 통해 유추해보건대 좋은 개발 문화란 곧 '현재'의 문제와 씨름하는 것을 넘어 '미래'를 향해 갈 수 있도록 독려하는 문화이지 싶다. 개발의 방향이 미래를 향한다는 것은 성장의 동력이 끊임없이 유입된다는 것이고, 그러기 위해서는 동료들끼리 상호자극이 되어야 한다. 그런 문화가 형성이 될 때 팀이 성장하고 비즈니스가 성장할 수 있는 것이다. 그리고 결국 좋은 개발 문화의 선순환의 결과로 개개인 역시 성장하게 된다. \n\n \n\n개발에서 자주 쓰이는 용어 중 하나가 '오픈 소스'(open source) 인데, 이는 개발자들이 지향해야 하는 지점을 총칭하는 표현이지 않나 싶다. 아이디어를 공유하고, 도움이 필요한 사람에게 도움을 제공하고, 더 좋은 해결책을 끊임없이 제안할 수 있는 개발자가 곧 성장하는 개발자이다. 자기주도성과 실력을 기반으로 더 넓은 시야를 갖출 수 있게 되기 때문이다. 이와 더불어 아직 공부하는 단계이기 때문에, 현업에 나가지 않았기 때문에 협업과 커뮤니케이션 역량을 방치해두는 것은 위험한 태도라고 느낀다. 오히려 더 많은 사람을 만날 기회가 있는 시기이기 때문에, 대외비 없이 자유롭게 개발 얘기를 할 수 있는 시기이기 때문에 더욱 그러한 역량을 키울 수 있다고 본다. 가고 싶은 기업이나 받고 싶은 연봉보다, 개발자로서의 역량을 키워나가는 실행력이 중요하다. \n\n \n\n3. 기술자는 인문학을, 인문학도는 기술을 이해해야 고속성장 할 수 있다\n김범준 대표는 공대 출신이지만 비즈니스 인사이트를 끊임없이 계발한 사업가이기도 하다. 기술에 대한 깊은 이해에 덧입혀진 비즈니스적 사고가 그를 이 자리까지 오게 하지 않았나 싶다. (이 자리라 함은, 한 기업을 이끄는 CEO 를 의미한다) 비단 김범준 대표가 아닌 다른 유니콘 (또는 series C, D 정도 수준의) 스타트업들의 핵심 인물들을 보고 있노라면 그들이 갖춘 공통 특성이 뚜렷해진다. 그것은 바로 기술과 인문학을 넘나드는 시야이다. \n\n \n\n스타트업에 종사하는 이들은 대부분 올라운드 플레이어다. 개발자이지만 기획도 하고 디자이너이지만 마케팅도 하는 사람들을 꽤나 자주 볼 수 있다. 스타트업 씬이 점점 청년들에게 요구하는 바가 많아지는 것은 상당히 유감이다만 거시적인 층위에서 그 원인을 찾아보자면 사회 자체가 기술과 인문학의 경계를 흐리고 있기 때문이다. 4차 산업혁명 시기에 들어서면서부터 기술은 곧 라이프스타일이 되었기 때문에 사람을 이해하는 인문학적 지식 (혹은 사람을 상대로 물건을 파는 경영 능력) 없이는 좋은 서비스를 만들기 어려워졌다. 기술만 잘 만들어도 찾아주는 곳이 많았던, 그리고 고전적인 방식으로 제품을 기획해도 중간은 갔던 과거와는 다르게 이제는 '사람들에게 먹힐 기술' 을 내놓지 않으면 팔리지 않는다. 때문에 성장에 욕심이 있는 사람이라면 둘 중 본인에게 부족한 부분을 찾아 메꾸는 것이 자연스럽다. 선택하는 방법론은 사람에 따라 다를 수는 있어도 궁극적인 지향점은 모두 '비즈니스 역량과 기술력 모두를 갖춘 자' 이지 않을까. \n\n \n\n기술을 잘 알고, 잘 쓰는 인문학도가 되고 싶은 욕심이 있다. 조금 더 욕심을 내보자면 지금보다 실력을 더욱 키워 '인문학 베이스를 갖춘 기술자'가 되고 싶다. 언제까지 개발자를 할지는 모르겠지만 적어도 하는 동안에는 좋은 개발자로 성장하고 싶다.",
            "contribution_date": new Date("2021-08-18T13:58:30.961Z"),
            "status": 100,
            "user_email": "haeun.yah@gmail.com",
            "contribution_id": 15
        }       
    ]
}